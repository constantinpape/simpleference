import numpy as np

from gunpowder.ext import tensorflow as tf
from gunpowder.nodes.generic_predict import GenericPredict
from gunpowder.volume import VolumeType, Volume
from gunpowder.tensorflow.local_server import LocalServer


# TODO
def build_tensorflow_prediction():
    pass


class TensorflowPredict(object):
    pass
    '''Tensorflow implementation of :class:`gunpowder.nodes.Predict`.

    Args:

        meta_graph_basename: Basename of a tensorflow meta-graph storing the
            trained tensorflow graph (aka a checkpoint), as created by
            :class:`gunpowder.nodes.Train`, for example.

        inputs (dict): Dictionary from the names of input tensors in the
            network to :class:``VolumeType`` or batch attribute name as string.

        outputs (dict): Dictionary from the names of output tensors in the
            network to :class:``VolumeType``. New volumes will be generated by
            this node for each entry (if requested downstream).

        volume_specs (dict, optional): An optional dictionary of
            :class:`VolumeType` to :class:`VolumeSpec` to set the volume specs
            of generated volumes (``outputs``). This is useful to set the
            ``voxel_size``, for example, if they differ from the voxel size of
            the input volumes. Only fields that are not ``None`` in the given
            :class:`VolumeSpec` will be used.
    '''

    def __init__(self,
                 meta_graph_basename,
                 inputs,
                 outputs):

        self.meta_graph_basename = meta_graph_basename
        self.inputs = inputs
        self.outputs = outputs

        self.graph = tf.Graph()
        self.session = tf.Session(graph=self.graph)

        with self.graph.as_default():
            self._read_meta_graph()

    def __call__(self, input_data):
        assert isinstance(input_data, dict)
        outputs = self.session.run(volume_outputs, feed_dict=input_data)

    def predict(self, batch, request):

        volume_outputs = self.__collect_requested_outputs(request)
        inputs = self.__collect_provided_inputs(batch)

        # compute outputs
        output = self.session.run(self.outputs, feed_dict=inputs)
        assert isinstance(output, np.ndarray)
        if output.ndim == 3:
            output = output[None]
        return output

    def _read_meta_graph(self):
        # read the meta-graph
        saver = tf.train.import_meta_graph(self.meta_graph_basename + '.meta',
                                           clear_devices=True)
        # restore variables
        saver.restore(self.session, self.meta_graph_basename)

    # Needs to be called in the end
    def stop(self):
        if self.session is not None:
            self.session.close()
            self.graph = None
            self.session = None
