import numpy as np
import os
from gunpowder.ext import tensorflow as tf

class TensorflowPredict(object):
    pass
    '''Tensorflow implementation of :class:`gunpowder.nodes.Predict`.

    Args:

        meta_graph_basename: Basename of a tensorflow meta-graph storing the
            trained tensorflow graph (aka a checkpoint), as created by
            :class:`gunpowder.nodes.Train`, for example.

        inputs (dict): Dictionary from the names of input tensors in the
            network to :class:``VolumeType`` or batch attribute name as string.

        outputs (dict): Dictionary from the names of output tensors in the
            network to :class:``VolumeType``. New volumes will be generated by
            this node for each entry (if requested downstream).

        volume_specs (dict, optional): An optional dictionary of
            :class:`VolumeType` to :class:`VolumeSpec` to set the volume specs
            of generated volumes (``outputs``). This is useful to set the
            ``voxel_size``, for example, if they differ from the voxel size of
            the input volumes. Only fields that are not ``None`` in the given
            :class:`VolumeSpec` will be used.
    '''

    def __init__(self,
                 meta_graph_basename,
                 input_key,
                 output_key):
        assert os.path.exists(meta_graph_basename+'.meta')
        self.meta_graph_basename = meta_graph_basename
        self.input_key = input_key
        self.output_key = output_key

        self.graph = tf.Graph()
        self.session = tf.Session(graph=self.graph)

        with self.graph.as_default():
            self._read_meta_graph()

    def __call__(self, input_data):
        assert isinstance(input_data, np.ndarray)
        output = self.session.run(self.output_key, feed_dict={self.input_key: input_data})[self.output_key]
        assert isinstance(output, np.ndarray)
        if output.ndim == 5:
            output = output[0]
        assert output.ndim == 4
        return output.astype('float32')

    def _read_meta_graph(self):
        # read the meta-graph
        saver = tf.train.import_meta_graph(self.meta_graph_basename + '.meta',
                                           clear_devices=True)
        # restore variables
        saver.restore(self.session, self.meta_graph_basename)

    # Needs to be called in the end
    def stop(self):
        if self.session is not None:
            self.session.close()
            self.graph = None
            self.session = None
